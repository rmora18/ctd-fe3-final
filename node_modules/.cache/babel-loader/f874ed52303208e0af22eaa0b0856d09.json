{"ast":null,"code":"'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport { VERSION } from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n};\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\nconst {\n  http: httpFollow,\n  https: httpsFollow\n} = followRedirects;\nconst isHttps = /https:?/;\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\n\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\n\n\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n\n  if (!proxy && proxy !== false) {\n    const proxyUrl = getProxyForUrl(location);\n\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n\n      const base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost; // Replace 'host' since options is not a URL object\n\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process'; // temporary hotfix\n\nconst wrapAsync = asyncExecutor => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    };\n\n    const _resolve = value => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = reason => {\n      done(reason, true);\n      reject(reason);\n    };\n\n    asyncExecutor(_resolve, _reject, onDoneHandler => onDone = onDoneHandler).catch(_reject);\n  });\n};\n/*eslint consistent-return:0*/\n\n\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {\n      data,\n      lookup,\n      family\n    } = config;\n    const {\n      responseType,\n      responseEncoding\n    } = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup && utils.isAsyncFn(lookup)) {\n      lookup = callbackify(lookup, entry => {\n        if (utils.isString(entry)) {\n          entry = [entry, entry.indexOf('.') < 0 ? 6 : 4];\n        } else if (!utils.isArray(entry)) {\n          throw new TypeError('lookup async function must return an array [ip: string, family: number]]');\n        }\n\n        return entry;\n      });\n    } // temporary internal emitter until the AxiosRequest class will be implemented\n\n\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    };\n\n    onDone((value, isRejected) => {\n      isDone = true;\n\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    } // Parse url\n\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath, 'http://localhost');\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize(); // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n    const onDownloadProgress = config.onDownloadProgress;\n    const onUploadProgress = config.onUploadProgress;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined; // support for spec compliant FormData objects\n\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n      data = formDataToStream(data, formHeaders => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      }); // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {}\n      }\n    } else if (utils.isBlob(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));\n      } // Add Content-Length header if data exists\n\n\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {\n          objectMode: false\n        });\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        length: contentLength,\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n      onUploadProgress && data.on('progress', progress => {\n        onUploadProgress(Object.assign(progress, {\n          upload: true\n        }));\n      });\n    } // HTTP basic authentication\n\n\n    let auth = undefined;\n\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n    let path;\n\n    try {\n      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set('Accept-Encoding', 'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false);\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth,\n      protocol,\n      family,\n      lookup,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    } // Create the request\n\n\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n      const streams = [res];\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress) {\n        const transformStream = new AxiosTransformStream({\n          length: utils.toFiniteNumber(responseLength),\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n        onDownloadProgress && transformStream.on('progress', progress => {\n          onDownloadProgress(Object.assign(progress, {\n            download: true\n          }));\n        });\n        streams.push(transformStream);\n      } // decompress the response body transparently if required\n\n\n      let responseStream = res; // return the last request in case of redirects\n\n      const lastRequest = res.req || req; // if decompress disabled we should not decompress\n\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'x-gzip':\n          case 'compress':\n          case 'x-compress':\n            // add the unzipper to the body stream processing pipeline\n            streams.push(zlib.createUnzip(zlibOptions)); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n\n          case 'deflate':\n            streams.push(new ZlibHeaderTransformStream()); // add the unzipper to the body stream processing pipeline\n\n            streams.push(zlib.createUnzip(zlibOptions)); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n\n          case 'br':\n            if (isBrotliSupported) {\n              streams.push(zlib.createBrotliDecompress(brotliOptions));\n              delete res.headers['content-encoding'];\n            }\n\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest);\n          responseStream.destroy(err);\n          reject(err);\n        });\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    }); // set tcp keep alive to prevent drop connection by peer\n\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n        return;\n      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n\n\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n\n        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n        abort();\n      });\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n      data.on('end', () => {\n        ended = true;\n      });\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\nexport const __setProxy = setProxy;","map":{"version":3,"names":["utils","settle","buildFullPath","buildURL","getProxyForUrl","http","https","util","followRedirects","zlib","VERSION","transitionalDefaults","AxiosError","CanceledError","platform","fromDataURI","stream","AxiosHeaders","AxiosTransformStream","EventEmitter","formDataToStream","readBlob","ZlibHeaderTransformStream","callbackify","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","brotliOptions","BROTLI_OPERATION_FLUSH","isBrotliSupported","isFunction","createBrotliDecompress","httpFollow","httpsFollow","isHttps","supportedProtocols","protocols","map","protocol","dispatchBeforeRedirect","options","beforeRedirects","proxy","config","setProxy","configProxy","location","proxyUrl","URL","username","auth","password","base64","Buffer","from","toString","headers","host","hostname","port","proxyHost","path","includes","beforeRedirect","redirectOptions","href","isHttpAdapterSupported","process","kindOf","wrapAsync","asyncExecutor","Promise","resolve","reject","onDone","isDone","done","value","isRejected","_resolve","_reject","reason","onDoneHandler","catch","httpAdapter","dispatchHttpRequest","data","lookup","family","responseType","responseEncoding","method","toUpperCase","rejected","req","isAsyncFn","entry","isString","indexOf","isArray","TypeError","emitter","onFinished","cancelToken","unsubscribe","abort","signal","removeEventListener","removeAllListeners","emit","type","once","subscribe","aborted","addEventListener","fullPath","baseURL","url","parsed","convertedData","status","statusText","Blob","env","err","ERR_BAD_REQUEST","stripBOM","Readable","normalize","set","onDownloadProgress","onUploadProgress","maxRate","maxUploadRate","undefined","maxDownloadRate","isSpecCompliantForm","userBoundary","getContentType","formHeaders","tag","boundary","isFormData","getHeaders","hasContentLength","knownLength","promisify","getLength","call","Number","isFinite","setContentLength","e","isBlob","size","setContentType","isStream","isBuffer","isArrayBuffer","Uint8Array","length","maxBodyLength","contentLength","toFiniteNumber","getContentLength","objectMode","pipeline","noop","on","progress","Object","assign","upload","urlUsername","urlPassword","delete","pathname","search","params","paramsSerializer","replace","customErr","Error","message","exists","toJSON","agents","httpAgent","httpsAgent","socketPath","transport","isHttpsRequest","test","agent","maxRedirects","Infinity","insecureHTTPParser","request","handleResponse","res","destroyed","streams","responseLength","transformStream","download","push","responseStream","lastRequest","decompress","statusCode","createUnzip","offListeners","finished","response","statusMessage","responseBuffer","totalResponseBytes","handleStreamData","chunk","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","handleStreamError","handleStreamEnd","responseData","concat","handleRequestError","handleRequestSocket","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","ended","errored","pipe","end","__setProxy"],"sources":["C:/Users/nayit/OneDrive/Desktop/DH/6Bimentre/Frontend III/ctd-fe3-final/fe3-final/node_modules/axios/lib/adapters/http.js"],"sourcesContent":["'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport {getProxyForUrl} from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup && utils.isAsyncFn(lookup)) {\n      lookup = callbackify(lookup, (entry) => {\n        if(utils.isString(entry)) {\n          entry = [entry, entry.indexOf('.') < 0 ? 6 : 4]\n        } else if (!utils.isArray(entry)) {\n          throw new TypeError('lookup async function must return an array [ip: string, family: number]]')\n        }\n        return entry;\n      })\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath, 'http://localhost');\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const onDownloadProgress = config.onDownloadProgress;\n    const onUploadProgress = config.onUploadProgress;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        length: contentLength,\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', progress => {\n        onUploadProgress(Object.assign(progress, {\n          upload: true\n        }));\n      });\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      lookup,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress) {\n        const transformStream = new AxiosTransformStream({\n          length: utils.toFiniteNumber(responseLength),\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', progress => {\n          onDownloadProgress(Object.assign(progress, {\n            download: true\n          }));\n        });\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'x-gzip':\n        case 'compress':\n        case 'x-compress':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'deflate':\n          streams.push(new ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress(brotliOptions));\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\n\nexport const __setProxy = setProxy;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}